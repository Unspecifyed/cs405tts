from gtts import gTTS

# Define the scripts for each slide
scripts = [
    "Greetings to all of you. Introducing the Green Pace Secure Development Policy today is me, Francis. We may use this approach to ensure that security practices are followed throughout the software development lifecycle. Let's examine how this policy safeguards our systems against new attacks and advances our defense-in-depth approach.",
    "Our security policy is a thorough structure that guarantees the integration of secure techniques into every stage of our development process. This policy was required to guarantee adherence to industry standards and safeguard Green Pace against the constantly changing cybersecurity landscape. In order to create a strong and secure environment, a defense-in-depth approach is necessary, and this policy supports that strategy by integrating security at every level, from coding standards to encryption procedures.",
    "Our coding standards are categorized in this 4-cell matrix according to their priority and probability of occurrence. High-priority problems, such string handling and SQL injection vulnerabilities, are visible in the top-left cell. These are our main areas of concentration because of their high probability and substantial impact. High-priority problems, such exception handling problems, that are less likely to arise but still require attention are listed in the bottom-left cell. Lower-priority concerns, on the other hand, are represented by the right column, where medium- and low-priority standards such as integer handling and memory management are arranged according to probability. We can easily prioritize and visualize our security activities with the help of this matrix.",
    "This presentation shows how the particular coding standards we've put in place match with our ten main security principles. To guarantee that each concept is upheld throughout our development process, it is backed by one or more standards. Examples of standards that support the 'Validate Input Data' concept include the STR50-CPP standard, which addresses string processing and buffer overflow prevention, and the IDS53-CPP standard, which guards against SQL injection vulnerabilities. Our dedication to incorporating security principles into our coding techniques is demonstrated by this alignment, which guarantees that these core security ideas serve as the foundation for all of our work.",
    "This presentation prioritizes our coding standards, starting with the ones that have the biggest possible influence and going down to the lowest importance. At the top of the list are two of the most prevalent and hazardous attacks in software security, buffer overflows and SQL injection, which are serious vulnerabilities addressed by STR50-CPP and IDS53-CPP. The memory management, error handling, and exception management rules that follow are essential for preserving system integrity and averting unanticipated failures. Last but not least, MSC50-CPP is given a medium priority rating since, although crucial for code robustness, it does not yet pose a security risk. By addressing the most serious threats first, this prioritizing enables us to make sure our software is as dependable and safe as possible.",
    "Protecting data that is kept on disk, whether it is in a file system, database, or cloud storage, is the goal of encryption at rest. We use robust encryption standards, such as AES-256, to make sure that the data is safe and unreadable even in the event that storage media are compromised due to theft, illegal access, or a breach. All types of stored data, including backups, logs, and any other sensitive data, are covered by this policy.",
    "The method of safeguarding data while it is being processed actively in memory is known as encryption in use. This is especially crucial in settings involving extremely sensitive data, such financial or personal transactions. Data protection strategies include hardware-based encryption and secure enclaves, which guarantee data protection even during manipulation or access. This lessens the chance of data disclosure or breaches as a result of side-channel attacks, memory dumps, or unwanted access during processing.",
    "Authentication, Authorization, and Accounting, or Triple-A, forms the foundation of our security rules. Every single one of these elements is essential to protecting our systems and making sure that access is regulated. The initial line of protection, authentication makes sure that only authorized individuals may access our systems. We enforce the usage of various kinds of verification by users, such as a password plus a hardware token or biometric verification, as part of multi-factor authentication (MFA). This lowers the likelihood of unwanted access considerably, even in the event that a password is stolen.",
    "After authentication, authorization limits what users who have been granted access to the system can do. We deploy Role-Based Access Control (RBAC), which distributes access according to a user's position inside the company. By doing this, it is ensured that users have access to the resources they require to do their jobs and nothing more. An HR staff member may have access to employee data but not the development environment, whereas a developer may have access to the coding but not sensitive financial details.",
    "The process of recording and keeping an eye on user activity within the system is called accounting. This guarantees a transparent audit trail by allowing users to track back every activity they perform. Important occurrences including file access, logins, modifications to important data, and administrative activities are all recorded. We can identify and react to suspicious activity by routinely examining these logs, which guarantees that any illegal or malicious action may be promptly found and dealt with.",
    "We are examining if the safeCopy function can effectively manage a standard string copy operation in this first test. The function receives the string 'Test' which it should copy into the buffer without any problems. Since this is a typical situation and there shouldn't be any mistakes, the test should pass.",
    "The function's handling of a string that precisely fits the buffer size—that is, less the space required for the null terminator—is examined in the second test. The string '123456789' is utilized, as it precisely fills the buffer. This is another instance where the test is anticipated to pass since the function should handle this input without any issues.",
    "The function's capability to handle strings with an early null terminator is examined in the third test. We want the method to successfully copy only 'Test' into the buffer, disregarding everything after the null terminator, based on our input of 'Test\\0Extra'. It should be confirmed that the function can handle null-terminated strings correctly if this test is likewise successful.",
    "In the fourth test, 'ThisIsTooLong,' we are purposefully giving a string that is too lengthy for the buffer. Here, we're testing the function's ability to recognize a possible overflow and generate a std::overflow_error. Since the test initiates the function's error handling, it is anticipated to fail as intended, proving that the function effectively avoids buffer overflows."
]

# Define a function to create the TTS audio for a given script and index
def create_audio(script, index):
    tts = gTTS(text=script, lang='en')
    tts.save(f"slide_{index + 1}.mp3")

# Use map to apply the function to each script with its index
list(map(lambda idx_script: create_audio(idx_script[1], idx_script[0]), enumerate(scripts)))

print("Audio files created successfully!")
